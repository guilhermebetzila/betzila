generator client { 
  provider   = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int       @id @default(autoincrement())
  email          String    @unique
  nome           String
  senha          String
  cpf            String?   @unique
  saldo          Float     @default(0)
  valorInvestido Float     @default(0)
  pontos         Int       @default(0)
  indicador      String?
  lastLogin      DateTime?

  // ðŸ‘‡ Carteira vinculada ao usuÃ¡rio
  carteira       String?   @unique

  indicadoPorId  Int?
  indicadoPor    User?     @relation("Indicacoes", fields: [indicadoPorId], references: [id])
  indicados      User[]    @relation("Indicacoes")

  graduacaoId    Int? 
  graduacao      Graduacao? @relation(fields: [graduacaoId], references: [id])

  cartelas        Cartela[]
  investimentos   Investimento[]
  depositos       Deposito[]
  rendimentos     RendimentoDiario[]
  onChainDeposits OnChainDeposit[]   // ðŸ‘ˆ Relacionamento com depÃ³sitos on-chain
}

model Deposito {
  id        Int      @id @default(autoincrement())
  valor     Float
  criadoEm  DateTime @default(now())

  userId    Int
  user      User     @relation(fields: [userId], references: [id])

  // ðŸ”¹ Novo campo
  status    StatusDeposito @default(pendente)
}

enum StatusDeposito {
  pendente
  confirmado
  cancelado
}

model Investimento {
  id                  Int      @id @default(autoincrement())
  valor               Float
  percentualDiario    Float    @default(0.025)
  rendimentoAcumulado Float    @default(0)
  criadoEm            DateTime @default(now())
  limite              Float    @default(0)
  ativo               Boolean  @default(true)

  userId              Int
  user                User     @relation(fields: [userId], references: [id])
}

model RendimentoDiario {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  dateKey    String
  base       Float
  rate       Float
  amount     Float
  creditedAt DateTime @default(now())

  @@unique([userId, dateKey])
  @@index([userId, dateKey])
}

model Partida {
  id          Int       @id @default(autoincrement())
  inicio      DateTime  @default(now())
  fim         DateTime?
  finalizada  Boolean   @default(false)
  aberta      Boolean   @default(true)
  encerrada   Boolean   @default(false)

  vencedoraId Int?      @unique
  vencedora   Cartela?  @relation("VencedoraDaPartida", fields: [vencedoraId], references: [id])

  cartelas    Cartela[]
  bolas       Bola[]
}

model Cartela {
  id               Int             @id @default(autoincrement())
  criadaEm         DateTime        @default(now())
  venceu           Boolean         @default(false)
  userId           Int?
  user             User?           @relation(fields: [userId], references: [id])
  partidaId        Int
  partida          Partida         @relation(fields: [partidaId], references: [id])
  numeros          NumeroCartela[]

  partidasVencidas Partida[]       @relation("VencedoraDaPartida")
}

model NumeroCartela {
  id        Int     @id @default(autoincrement())
  numero    Int
  cartelaId Int
  cartela   Cartela @relation(fields: [cartelaId], references: [id])
}

model Bola {
  id        Int     @id @default(autoincrement())
  numero    Int
  ordem     Int
  partidaId Int
  partida   Partida @relation(fields: [partidaId], references: [id])
}

model Graduacao {
  id     Int    @id @default(autoincrement())
  nome   String
  pontos Int    @unique
  users  User[]
}

//
// === Modelo para depÃ³sitos on-chain (USDT na BSC) ===
//
model OnChainDeposit {
  id        Int      @id @default(autoincrement())
  txHash    String   @unique
  from      String
  to        String
  amount    Float
  createdAt DateTime @default(now())

  // ðŸ‘‡ Relacionamento com User (opcional, mas ideal)
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])

  // ðŸ”¹ Novo campo de status
  status    StatusDeposito @default(pendente)
}
